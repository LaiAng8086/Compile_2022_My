# 编译技术设计文档

20373787 荆睿涛

## 一、参考编译器介绍

## 二、编译器总体设计

### 文件结构

`Frontend`目录：编译器前端，包括词法分析和语法分析

- `Lexer`目录：词法分析相关
  - `SrcReader`：词法分析器
  - `Token`：单词存储类，以及一些常量的定义，方便词法分析中字符串比较归类
  - `TokenOutput`：单词库类，方便语法分析部分读取单词，以及词法分析作业的输出

- `Syntax`目录：语法分析相关
  - `Parser`子目录：每种非终结符的解析子程序（在此略去各个非终结符的列举）
  - `Storage`子目录：每种非终结符解析后相关信息的存储类，便于形成语法树结构，以及语法分析作业的输出。

## 三、词法分析设计

### 编码前的设计

在解析单词的部分，我主要参考了实验指导书中的思路，使用**有限状态自动机DFA**来处理所有的关键字和标识符。该DFA的状态如下图所示：

<img src="https://laiang8086-test.oss-cn-beijing.aliyuncs.com/images/202210061700601.png" width=600>

为了简单起见，我们不妨先讨论当状态机处于注释状态的两种特殊情况，再讨论状态机处于非注释状态的正常情况。

当状态机处于`SINGLE COMMENT`状态时，相当于已经位于该行的单行注释中，故该行剩下的字符都无需读取了，直接换到下一行，而且将状态机的状态设为`DFA_INIT`。

当状态机处于`MULTI COMMENT`状态时，相当于处于多行状态中，这时先读两个字符（第二个是预读，指针不移动）看是不是`*/`，如果是则可以推出多行注释状态，回到正常状态`DFA_INIT`，如果不是就移动到下一个字符处。

然后在非注释的状态中，如果处于`DFA_INTCON`状态中，则如图连续读取数字直到非数字的字符出现；如果处于`DFA_FORMATSTRING`状态中，则连续读取字符直到`"`出现结束回到`DFA_INTCON`。如果处于`DFA_IDENT`状态中，则连续读大小写字母或下划线，直到标识符读取的结束。这里值得注意的是，该状态读取的单词并不一定均为标识符，也有可能是关键字，因此需要特判一下。

最后介绍重头戏——在`DFA_INIT`状态下的各种单词种类的划分。

首先，我们判断当前字符是不是下划线、大小写字符，如果是，则说明开始读取标识符了，移动到下一个字符并转移到`DFA_IDENT`状态。

如果不是，则开始判断当前字符是不是`[0-9]`数字，如果是，则说明开始读取数字常量了，移动到下一个字符并转移到`DFA_INTCON`状态。

如果不是，则首先判断当前的两个字符是否是**双字符运算符**，再判断当前字符是否是**单字符运算符**，最后如果还不是，则判断当前字符是不是括号、分号等其他字符，这样各种类别基本上就都考虑到了。

对于单词的存储，我记录了这个**单词的名称、类别和行号**，以方便后续语法分析和错误处理使用。

### 编码完成后的修改

为了提高效率，当读取结束一个有效的单词成分后，写了一个`skipUseless()`函数，以批量跳过多余的空白字符，避免空白字符混入状态机做太多无效判断。

## 四、语法分析设计

### 编码前的设计

#### 消除左递归

官方文档中对于以下几条文法存在左递归现象，显然是不能直接用来递归下降的，故进行了改写。

原文法

```java
乘除模表达式 MulExp → UnaryExp | MulExp ('*' | '/' | '%') UnaryExp // 1.UnaryExp 2.* 3./ 4.% 均需覆盖 
加减表达式 AddExp → MulExp | AddExp ('+' | '−') MulExp // 1.MulExp 2.+ 需覆盖 3.- 需覆盖 
关系表达式 RelExp → AddExp | RelExp ('<' | '>' | '<=' | '>=') AddExp // 1.AddExp 2.< 3.> 4.<= 5.>= 均需覆盖 
相等性表达式 EqExp → RelExp | EqExp ('==' | '!=') RelExp // 1.RelExp 2.== 3.!= 均 需覆盖 
逻辑与表达式 LAndExp → EqExp | LAndExp '&&' EqExp // 1.EqExp 2.&& 均需覆盖 
逻辑或表达式 LOrExp → LAndExp | LOrExp '||' LAndExp // 1.LAndExp 2.|| 均需覆盖
```

修改后文法

```java
MulExp -> UnaryExp {('*'|'/'|'%') UnaryExp}
AddExp -> MulExp {('+'|'-') MulExp}
RelExp -> AddExp {('<' | '>' | '<=' | '>=') AddExp}
EqExp -> RelExp {('==' | '!=') RelExp}
LAndExp -> EqExp {'&&' EqExp}
LOrExp -> LAndExp {'||' LAndExp}
```

不过由于输出的要求，拿`MulExp`为例，相当于只有最右边的一个`UnaryExp`是独立的，前面的都相当于外面套了一个`MulExp`，因此在输出时就特判一下，如果`MulExp`包含两个及以上的`UnaryExp`，那么不到最后一个`UnaryExp`时，一定要补上一个`MulExp`。

那么递归下降子程序在编写时就按照修改后的文法就行操作了。

#### 语法树的建立

基于语法树建立的初衷，我的编译器的语法分析部分，**每个**非终结符的语法树节点存储类和解析类**都是独立的**（也就是说有二三十个Java文件）。这样当然降低了类之间的耦合度，不过可能也使得相似文法的代码较为冗余。

由于每个非终结符的语法树节点均单独建类，故类的成员属性就非常清晰了——**产生式左部**对应的非终结符的存储类，包含**产生式右部**所有可能推导到的非终结符的存储类的实例对象，或者涉及到的**终结符**，**在词法分析得到的词列表中的位置**（数组下标）。

同时，考虑到**同一个左部非终结符**的**推导规则有多条**的情形，在存储类中，也专门设了一个成员属性来表明实际上是通过何种规则推导的。

举个例子，比如`PrimaryExp`

```java
PrimaryExp -> '('Exp')' | LVal | Number
```

那么当递归下降子程序完成对该语法成分的推导后，不仅要传给`PrimaryExp`存储类实例变量对应的`Exp`对象或`LVal`对象或`Number`对象，而且要到底是哪条规则（1,2,3？），这样才方便最终输出时找对应的子成分去输出，而不要输出其他没用到的成分。

#### 超前扫描

超前扫描的主要意义在于，部分产生式的几个候选式，右部的FIRST集合有所相交，也有存在部分产生式之间的右部FIRST集合存在相交，这个时候就需要多预读（不移动当前单词指针）几个单词，来充分确定到底是用哪条规则推导。

举几个例子来说明。

- `Decl`如果推导为`VarDecl`，和`FuncDef`推导的第一个成分`FuncType`，有可能都是`INTTK`，而且下一个单词还都是`Ident`。这个时候就需要再预读一个单词，如果是`(`，则按照`FuncDef`处理，否则按照`Decl`处理。

- 比较复杂的是`Stmt`语句的分类

  先列出文法的所有情况

  ```java
  Stmt -> LVal '=' Exp ';'
      |   LVal '=' 'getint' '(' ')' ';'
      |   [Exp] ';'
      |   Block
      |   'if' '(' Cond ')' Stmt ['else' Stmt]
      |   'while' '(' Cond ')' Stmt
      |   'break' ';'
      |   'continue' ';'
      |   'return' [Exp] ';'
      |   'printf' '(' FormatString {',' Exp} ')' ';'
  ```

  首先，通过第一个单词，就可以区分出if语句，while语句，break语句，continue语句，return语句，printf语句和Block语句（注意Block一定是`'{'`开头），对于这些成分直接调用相应的子程序即可。

  然后观察剩下的三个候选式，考虑如下的推导情形

  ```java
  Exp -> AddExp -> MulExp -> UnaryExp -> PrimaryExp -> LVal 
  ```

  所以，这就是为什么不能直接读一个`LVal`再看`=`的原因，因为有可能这个`Stmt`会推导为`Exp`。

  但是，与此同时我们却发现一种**贪心**的思路，那就是剩下三种情况就直接按照`Exp`去解析，原因是，如果最后证实这个`Stmt`是应当被推导为`Exp`的，那么这么做就顺利地完成了`Exp`的解析，让单词指针落到`;`处。否则的话，那就说明是前两个候选式，而这个时候如果按`Exp`去解析，也会解析出一个完整的`LVal`而单词指针落到`=`处。如此以来，只需要从`Exp`解析结果中把`LVal`掏出来就行。

  那么最后落到前两个候选式，只需要判断一下等号后面的单词是不是`getint`就能加以区分了。

如此以来，我们就通过超前扫描，在避免回溯的情况下，完成了递归下降语法分析。

### 其他设计事项

为了方便起见，没有单独设`BlockItem`类，而是直接将`Block`括号里的部分，要么推导为`Decl`，要么推导为`Stmt`。

在词法分析上迭代开发，在`TokenOutput`类里，设立一个单词指针来记录当前读取单词的数组下标，所有的递归下降分析器均可以调用公共静态函数来获取当前Token。

### 编码完成后的修改

- 方便`debug`，在部分非终结符的解析器中加入调试开关，方便输出调试信息
- 抽象了一个语法树节点的接口，一个非终结符解析器接口，以统一获取产生式右端非终结符的解析结果，和利于输出。

## 五、错误处理设计

## 六、代码生成设计

## 七、代码优化设计

